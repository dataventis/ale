;;;; ale core: assembler bootstrapping

(asm*
    .eval (asm* !make-special (name)
        .const name
        dup
        declare)
    .const declare*
    bind

    .eval (asm* !make-special (name)
        .const name
        dup
        private)
    .const private*
    bind

    .eval (asm* !make-special (name value)
        .eval value
        dup
        .const name
        bind)
    .const define*
    bind
    ; block evaluator will pop this
    null)

(define* if
  (asm* !make-special
    [(predicate consequent alternative)
          .eval predicate
          cond-jump :consequent
          .eval alternative
          jump :end
      :consequent
          .eval consequent
      :end]
    [(predicate consequent)
          .eval predicate
          cond-jump :consequent
          null
          jump :end
      :consequent
          .eval consequent
      :end]))

(define* cons
  (lambda (car cdr)
    (asm*
        .resolve cdr
        .resolve car
        cons)))

(private* dec*)
(define* dec*
  (asm* !make-special (value)
      .eval value
      .const 1
      sub))

(define* apply
  (lambda
    [(func args)
       (asm*
           .resolve args
           .resolve func
           call-with)]
    [(func f . r)
       (let-rec
         [prepend-args
          (lambda (args result idx)
            (if (asm* .resolve idx zero num-gte)
                (prepend-args args (cons (args idx) result) (dec* idx))
                result))]
         (let [idx (dec* (length r))]
           (let [args (prepend-args r (r idx) (dec* idx))]
             (asm*
                 .eval (cons f args)
                 .resolve func
                 call-with))))]))
