;;;; ale core: definition facilities

(private* is-cons-or-list)
(define* is-cons-or-list
  (lambda (value)
    (or (is-cons value)
        (is-list value))))

(private* parse-define)
(define* parse-define
  (lambda (body)
    (let ([f (car body)]
          [r (cdr body)])
      (if ({:private #t :macro #t} f)
          (assoc (parse-define r) f #t)
          (if (and (is-cons-or-list f) (is-local (car f)))
              {:name (car f) :lambda #t :body `(lambda ,(cdr f) ,@r)}
              (if (is-local f)
                  {:name f :body (car r)}
                  (raise (str "invalid define: " body))))))))

(define* define
  (macro*
    (lambda body
      ; we're so early days that let* hasn't been defined yet
      (let [parsed (parse-define body)]
        (let ([name (:name parsed)]
              [body (:body parsed)])
          (let [value (if (:macro parsed) `(macro* ,body) body)]
            (let [labeled (if (:lambda parsed) `(label ,name ,value) value)]
              (if (:private parsed)
                  `(begin (private* ,name) (define* ,name ,labeled))
                  `(define* ,name ,labeled)))))))))

(define :macro (define-macro . forms)
  (let [name (car forms)]
    (if (is-local name)
        `(define ,name (label ,name (macro* (lambda ,@(cdr forms)))))
        `(define :macro ,@forms))))

(define-macro (define-lambda . forms)
  (let [name (car forms)]
    (if (is-local name)
        `(define ,name (label ,name (lambda ,@(cdr forms))))
        `(define ,@forms))))

(define-macro (lambda-rec name . forms)
  (if (is-local name)
    `(label ,name (lambda ,@forms))
    `(lambda ,name ,@forms)))

(define-macro (thunk . forms)
  `(lambda () ,@forms))

(define-macro (declare . names)
  `(begin ,@(map! (lambda (n) (list 'ale/declare* n)) names)))

(define-macro (private . names)
  `(begin ,@(map! (lambda (n) (list 'ale/private* n)) names)))
