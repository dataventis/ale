;;;; ale core: basics

(define* quote
  (asm*
      !make-encoder (form)
      .const form))

(define* nil '())
(define* true #t)
(define* false #f)

(define* first car)
(define* rest cdr)

(define* apply
  (lambda
    [(fn args)
       (asm*
           .resolve args
           .resolve fn
           call-with)]
    [(fn f . r)
       (let-rec
         [prepend-args
          (lambda (args result idx)
            (if (asm* .resolve idx zero num-gte)
                (prepend-args args
                              (cons (args idx) result)
                              (asm* .resolve idx .const 1 sub))
                result))]
         (let [idx (asm* .eval (length r) .const 1 sub)]
           (let [args (prepend-args r
                                    (r idx)
                                    (asm* .resolve idx .const 1 sub))]
             (asm*
                 .eval (cons f args)
                 .resolve fn
                 call-with))))]))

;; syntax-quoting requires it
(define* concat!
  (lambda colls
    (let-rec
      [concat-inner
       (lambda (colls head)
         (if (is-empty colls)
             (apply list head)
             (let ([f (car colls)]
                   [r (cdr colls)])
               (if (is-empty f)
                   (concat-inner r head)
                   (concat-inner (cons (cdr f) r)
                                 (append head (car f)))))))]
      (concat-inner colls []))))

(define* label
  (macro*
    (lambda (name form)
      `(let-rec [,name ,form] ,name))))

;; case and some macros require it
(define* map!
  (label map!
    (lambda (func coll)
      (if (is-empty coll)
        '()
        (cons (func (first coll))
              (map! func (rest coll)))))))

(define* and
  (macro*
    (lambda
      [() true]
      [(clause) clause]
      [clauses
         `(let [and# ,(clauses 0)]
            (if and#
                (and ,@(rest clauses))
                and#))])))

(define* or
  (macro*
    (lambda
      [() nil]
      [(clause) clause]
      [clauses
         `(let [or# ,(clauses 0)]
            (if or#
                or#
                (or ,@(rest clauses))))])))

(define* raise
  (lambda (err)
    (asm*
        .resolve err
        panic
        nil)))
