;;;; ale core: basics

;; basic predicates
(define* is-apply (is-a :func))
(define* is-atom (is-a :atom))
(define* is-appendable (is-a :appender))
(define* is-boolean (is-a :boolean))
(define* is-cons (is-a :cons))
(define* is-counted (is-a :counted))
(define* is-indexed (is-a :indexed))
(define* is-keyword (is-a :keyword))
(define* is-list (is-a :list))
(define* is-local (is-a :local))
(define* is-macro (is-a :macro))
(define* is-mapped (is-a :mapped))
(define* is-nan (is-a :nan))
(define* is-number (is-a :number))
(define* is-object (is-a :object))
(define* is-pair (is-a :pair))
(define* is-promise (is-a :promise))
(define* is-qualified (is-a :qualified))
(define* is-resolved (is-a :resolved))
(define* is-reversible (is-a :reverser))
(define* is-seq (is-a :seq))
(define* is-special (is-a :special))
(define* is-string (is-a :string))
(define* is-symbol (is-a :symbol))
(define* is-vector (is-a :vector))

(define* quote
  (asm*
      !make-encoder (form)
      .const form))

(private* dec*)
(define* dec*
  (asm*
      !make-encoder (value)
      .eval value
      .const 1
      sub))

(define* apply
  (lambda
    [(fn args)
       (asm*
           .resolve args
           .resolve fn
           call-with)]
    [(fn f . r)
       (let-rec
         [prepend-args
          (lambda (args result idx)
            (if (asm* .resolve idx zero num-gte)
                (prepend-args args (cons (args idx) result) (dec* idx))
                result))]
         (let [idx (dec* (length r))]
           (let [args (prepend-args r (r idx) (dec* idx))]
             (asm*
                 .eval (cons f args)
                 .resolve fn
                 call-with))))]))

;; syntax-quoting requires it
(define* concat!
  (lambda colls
    (let-rec
      [concat-inner
       (lambda (colls head)
         (if (is-empty colls)
             (apply list head)
             (let ([f (car colls)]
                   [r (cdr colls)])
               (if (is-empty f)
                   (concat-inner r head)
                   (concat-inner (cons (cdr f) r)
                                 (append head (car f)))))))]
      (concat-inner colls []))))

(define* label
  (macro*
    (lambda (name form)
      `(let-rec [,name ,form] ,name))))

;; case and some macros require it
(define* map!
  (label map!
    (lambda (func coll)
      (if (is-empty coll)
        '()
        (cons (func (car coll))
              (map! func (cdr coll)))))))

(define* and
  (macro*
    (lambda
      [() #t]
      [(clause) clause]
      [clauses
         `(let [and# ,(clauses 0)]
            (if and#
                (and ,@(cdr clauses))
                and#))])))

(define* or
  (macro*
    (lambda
      [() '()]
      [(clause) clause]
      [clauses
         `(let [or# ,(clauses 0)]
            (if or#
                or#
                (or ,@(cdr clauses))))])))

(define* raise
  (lambda (err)
    (asm*
        .resolve err
        panic
        nil)))

(private* reduce-inst)
(define* reduce-inst (macro* (lambda (args init inst)
  (apply list (concat!
    '(ale/asm*
        .local accum :val
        .eval) [init] '(
        store accum
        .local rest :val
        .resolve) [args] '(
        store rest
    :loop
        load rest
        empty
        cond-jump :end
        load accum
        load rest
        car)
        [inst] '(
        store accum
        load rest
        cdr
        store rest
        jump :loop
    :end
        load accum))))))

(private* predicate-inst)
(define* predicate-inst (macro* (lambda (f r inst)
  (apply list (concat!
    '(ale/asm*
         .local prev :val
         .resolve) [f] '(
         store prev
         .local rest :val
         .resolve) [r] '(
         store rest
     :loop
         load rest
         empty
         cond-jump :success
         load prev
         load rest
         car
         ) [inst] '(
         cond-jump :next
         false
         jump :end
     :next
         load rest
         dup
         car
         store prev
         cdr
         store rest
         jump :loop
     :success
         true
     :end))))))
