;;;; ale core: basics

(define* *pos-inf* (/ 1.0 0.0))
(define* *neg-inf* (/ -1.0 0.0))

(define* true #t)
(define* false #f)
(define* nil '())

(define* first car)
(define* rest cdr)

(define* inc (lambda (value) (+ value 1)))
(define* dec (lambda (value) (- value 1)))

(declare* apply)
(define* apply
  (lambda
    [(fn args)
       (asm*
           .resolve args
           .resolve fn
           call-with)]
    [(fn f . r)
       (let-rec
         [prepend-args
          (lambda (args result idx)
            (if (>= idx 0)
                (prepend-args args (cons (args idx) result) (dec idx))
                result))]
         (let [idx (dec (length r))]
           (let [args (prepend-args r (r idx) (dec idx))]
             (asm*
                 .eval (cons f args)
                 .resolve fn
                 call-with))))]))

;; syntax-quoting requires it
(define* concat!
  (lambda colls
    (let-rec
      [concat-inner
       (lambda (colls head)
         (if (is-empty colls)
             (apply list head)
             (let ([f (first colls)]
                   [r (rest colls)])
               (if (is-empty f)
                   (concat-inner r head)
                   (concat-inner (cons (rest f) r)
                                 (append head (first f)))))))]
      (concat-inner colls []))))

(define* and
  (macro*
    (lambda
      [() true]
      [(clause) clause]
      [clauses
         `(let [and# ,(clauses 0)]
            (if and#
                (and ,@(rest clauses))
                and#))])))

(define* or
  (macro*
    (lambda
      [() nil]
      [(clause) clause]
      [clauses
         `(let [or# ,(clauses 0)]
            (if or#
                or#
                (or ,@(rest clauses))))])))

(define* label
  (macro*
    (lambda (name form)
      `(let-rec [,name ,form] ,name))))

;; bootstrap the basic lambda, macro, and definition facilities

(private* is-cons-or-list)
(define* is-cons-or-list
  (lambda (value)
    (or (is-cons value)
        (is-list value))))

(private* parse-define)
(define* parse-define
  (lambda (body)
    (let ([f (car body)]
          [r (cdr body)])
      (if ({:private #t :macro #t} f)
          (assoc (parse-define r) f #t)
          (if (and (is-cons-or-list f) (is-local (car f)))
              {:name (car f) :lambda #t :body `(lambda ,(cdr f) ,@r)}
              (if (is-local f)
                  {:name f :body (car r)}
                  (raise (str "invalid define: " body))))))))

(define* define
  (macro*
    (lambda body
      ; we're so early days that let* hasn't been defined yet
      (let [parsed (parse-define body)]
        (let ([name (:name parsed)]
              [body (:body parsed)])
          (let [value (if (:macro parsed) `(macro* ,body) body)]
            (let [labeled (if (:lambda parsed) `(label ,name ,value) value)]
              (if (:private parsed)
                  `(begin (private* ,name) (define* ,name ,labeled))
                  `(define* ,name ,labeled)))))))))

(define :macro (define-macro . forms)
  (let [name (car forms)]
    (if (is-local name)
        `(define* ,name (label ,name (macro* (lambda ,@(cdr forms)))))
        `(define :macro ,@forms))))

(define-macro (define-lambda . forms)
  (let [name (car forms)]
    (if (is-local name)
        `(define* ,name (label ,name (lambda ,@(cdr forms))))
        `(define ,@forms))))

(define-macro (!eq value . comps)
  `(not (eq ,value ,@comps)))

(define-macro (!and . clauses)
  `(not (and ,@clauses)))

(define-macro (!or . clauses)
  `(not (or ,@clauses)))

(define-macro (lambda-rec name . forms)
  (if (is-local name)
      `(label ,name (lambda ,@forms))
      `(lambda ,name ,@forms)))

(define-macro (thunk . forms)
  `(lambda () ,@forms))

;; case and some macros require it
(define (map! func coll)
   (if (is-empty coll)
       '()
       (cons (func (first coll))
             (map! func (rest coll)))))

(define-macro (declare . names)
  `(begin ,@(map! (lambda (n) (list 'ale/declare* n)) names)))

(define-macro (private . names)
  `(begin ,@(map! (lambda (n) (list 'ale/private* n)) names)))

;; some basic predicates

(define (is-null value)
  (eq value nil))

(define (is-zero value)
  (= value 0))

(define (is-even value)
  (= (mod value 2) 0))

(define (is-odd value)
  (= (mod value 2) 1))

(define (is-true value)
  (eq true value))

(define (is-false value)
  (eq false value))

(define (not value)
  (if value false true))

;; some conveniences

(define (no-op . _))

(define (identity value) value)

(define (constantly value)
  (lambda _ value))

(define-macro (: target method . args)
  `((get ,target ,method) ,@args))
