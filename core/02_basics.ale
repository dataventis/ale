;;;; ale core: basics

(define* quote
  (asm*
    !make-encoder (form)
    .const form))

;; type-based predicates
(define* is-any     (is-a* :any))
(define* is-apply   (is-a* :function))
(define* is-boolean (is-a* :boolean))
(define* is-cons    (is-a* :cons))
(define* is-keyword (is-a* :keyword))
(define* is-macro   (is-a* :macro))
(define* is-null    (is-a* :null))
(define* is-number  (is-a* :number))
(define* is-object  (is-a* :object))
(define* is-special (is-a* :special))
(define* is-string  (is-a* :string))
(define* is-symbol  (is-a* :symbol))
(define* is-vector  (is-a* :vector))

;; derived predicates
(define* is-atom       (is-a* :atom))
(define* is-appendable (is-a* :appender))
(define* is-counted    (is-a* :counted))
(define* is-indexed    (is-a* :indexed))
(define* is-list       (is-a* :list))
(define* is-local      (is-a* :local))
(define* is-mapped     (is-a* :mapped))
(define* is-nan        (is-a* :nan))
(define* is-pair       (is-a* :pair))
(define* is-promise    (is-a* :promise))
(define* is-qualified  (is-a* :qualified))
(define* is-resolved   (is-a* :resolved))
(define* is-reversible (is-a* :reverser))
(define* is-seq        (is-a* :sequence))

(private* dec*)
(define* dec*
  (asm*
      !make-encoder (value)
      .eval value
      .const 1
      sub))

(define* apply
  (lambda
    [(func args)
       (asm*
           .resolve args
           .resolve func
           call-with)]
    [(func f . r)
       (let-rec
         [prepend-args
          (lambda (args result idx)
            (if (asm* .resolve idx zero num-gte)
                (prepend-args args (cons (args idx) result) (dec* idx))
                result))]
         (let [idx (dec* (length r))]
           (let [args (prepend-args r (r idx) (dec* idx))]
             (asm*
                 .eval (cons f args)
                 .resolve func
                 call-with))))]))

;; syntax-quoting requires it
(define* concat!
  (lambda colls
    (let-rec
      [concat-inner
       (lambda (colls head)
         (if (is-empty colls)
             (apply list head)
             (let ([f (car colls)]
                   [r (cdr colls)])
               (if (is-empty f)
                   (concat-inner r head)
                   (concat-inner (cons (cdr f) r)
                                 (append head (car f)))))))]
      (concat-inner colls []))))

(define* label
  (macro*
    (lambda (name form)
      `(let-rec [,name ,form] ,name))))

;; case and some macros require it
(define* map!
  (label map!
    (lambda (func coll)
      (if (is-empty coll)
        '()
        (cons (func (car coll))
              (map! func (cdr coll)))))))

(define* and
  (macro*
    (lambda
      [() #t]
      [(clause) clause]
      [clauses
         `(let [and# ,(car clauses)]
            (if and#
                (and ,@(cdr clauses))
                and#))])))

(define* or
  (macro*
    (lambda
      [() #f]
      [(clause) clause]
      [clauses
         `(let [or# ,(car clauses)]
            (if or#
                or#
                (or ,@(cdr clauses))))])))

(define* raise
  (lambda (err)
    (asm*
        .resolve err
        panic
        null)))

(private* reduce-inst)
(define* reduce-inst (macro* (lambda (args init inst)
  (apply list (concat!
    '(ale/asm*
        .private accum :val
        .eval) [init] '(
        store accum
        .private rest :val
        .resolve) [args] '(
        store rest
    :loop
        load rest
        empty
        cond-jump :end
        load accum
        load rest
        car)
        [inst] '(
        store accum
        load rest
        cdr
        store rest
        jump :loop
    :end
        load accum))))))

(private* predicate-inst)
(define* predicate-inst (macro* (lambda (f r inst)
  (apply list (concat!
    '(ale/asm*
         .private prev :val
         .resolve) [f] '(
         store prev
         .private rest :val
         .resolve) [r] '(
         store rest
     :loop
         load rest
         empty
         cond-jump :success
         load prev
         load rest
         car
         ) [inst] '(
         cond-jump :next
         false
         jump :end
     :next
         load rest
         dup
         car
         store prev
         cdr
         store rest
         jump :loop
     :success
         true
     :end))))))

(define* begin
  (macro*
    (lambda body
      ; an empty let results in the desired scoping behavior
      `(let () ,@body))))
