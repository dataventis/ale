;;;; ale core: basics

(define* *pos-inf* (/ 1.0 0.0))
(define* *neg-inf* (/ -1.0 0.0))

(define* true #t)
(define* false #f)
(define* nil '())

(define* first car)
(define* rest cdr)

;; syntax-quoting requires it
(define* concat!
  (lambda colls
    (let-rec [concat-inner
              (lambda (colls head)
                (if (is-empty colls)
                  (apply list head)
                  (let ([f (first colls)]
                        [r (rest colls)])
                    (if (is-empty f)
                      (concat-inner r head)
                      (concat-inner (cons (rest f) r)
                                    (append head (first f)))))))]
      (concat-inner colls []))))

;; bootstrap the basic lambda, macro, and definition facilities

(define* label
  (macro
    (lambda (name form)
      `(let-rec [,name ,form] ,name))))

(private* is-cons-or-list)
(define* is-cons-or-list
  (lambda (value)
    (if (is-cons value)
      true
      (is-list value))))

(private* make-macro)
(define* make-macro
  (lambda (quoter)
    (macro
      (lambda forms
        (let ([f (car forms)]
              [r (cdr forms)])
          (if (is-cons-or-list f)
            (quoter (car f) (cons (cdr f) r))
            (quoter f r)))))))

(define* define-lambda
  (make-macro
    (lambda (name body)
      `(define* ,name
         (label ,name (lambda ,@body))))))

(define* define-macro
  (make-macro
    (lambda (name body)
      `(define* ,name
         (label ,name (macro (lambda ,@body)))))))

(define-macro (!eq value . comps)
  `(not (eq ,value ,@comps)))

(define-macro and
  [() true]
  [(clause) clause]
  [clauses
    `(let [and# ,(clauses 0)]
       (if and#
              (and ,@(rest clauses))
              and#))])

(define-macro (!and . clauses)
  `(not (and ,@clauses)))

(define-macro or
  [() nil]
  [(clause) clause]
  [clauses
    `(let [or# ,(clauses 0)]
       (if or#
             or#
             (or ,@(rest clauses))))])

(define-macro (!or . clauses)
  `(not (or ,@clauses)))

(define-macro assert-args
  [() nil]
  [(clause)
    (raise "assert-args clauses must be paired")]
  [clauses
    `(if ,(clauses 0)
       (assert-args ,@(rest (rest clauses)))
       (raise ,(clauses 1)))])

(define-macro (define . body)
  (let [value (first body)]
    (assert-args
      (or (is-local value)
          (is-cons-or-list value))
      (str "invalid define: " value))
    (if (is-local value)
      `(define* ,@body)
      `(define-lambda ,@body))))

(define-macro (lambda-rec name . forms)
  (if (is-local name)
    `(label ,name (lambda ,@forms))
    `(lambda ,name ,@forms)))

(define-macro (thunk . forms)
  `(lambda () ,@forms))

;; case and some macros require it
(define-lambda map! (func coll)
   (if (is-empty coll)
     '()
     (cons (func (first coll))
           (map! func (rest coll)))))

(define-macro (declare . names)
  `(begin ,@(map! (lambda (n) (list 'ale/declare* n)) names)))

(define-macro (private . names)
  `(begin ,@(map! (lambda (n) (list 'ale/private* n)) names)))

;; some basic predicates

(define (is-null value)
  (eq value nil))

(define (is-zero value)
  (= value 0))

(define (is-even value)
  (= (mod value 2) 0))

(define (is-odd value)
  (= (mod value 2) 1))

(define (is-true value)
  (eq value true))

(define (is-false value)
  (eq value false))

(define (not value)
  (if value false true))

;; some conveniences

(define (inc value)
  (+ value 1))

(define (dec value)
  (- value 1))

(define (no-op . _))

(define (identity value) value)

(define (constantly value)
  (lambda _ value))

(define-macro (: target method . args)
  `((get ,target ,method) ,@args))
